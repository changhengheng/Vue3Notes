# reactive 的基本使用

作用：定义多个数据的响应式
使用：`const proxy = reactive(obj)`，接收一个普通对象然后返回该普通对象的响应式代理器对象
响应式转换是“深层的”：会影响对象内部所有嵌套的属性（不管嵌套了多少层）
内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的

示例代码：

```js
<template>
  <h2>reactive的基本使用</h2>
  // 4. 使用ref数据
  <h3>名字：{{ user.name }}</h3>
  <h3>年龄：{{ user.age }}</h3>
  <h3>头发：{{ user.hair }}</h3>
  <button @click="updateUser">更新数据</button>
</template>

<script lang="ts">
// 1. 引入reactive函数
import { reactive } from "vue";
export default {
  name: "App",
  // 需求：显示用户的相关信息，点击按钮，可以更新用户端相关信息系数据
  setup() {
    // 目标对象obj
    const obj = {
      name: "法外狂徒张三",
      age: 18,
      hair: {
        length: 180,
        color: "五彩缤纷的蓝",
      },
    }
    // 2. 使用reactive把复杂数据变成响应式的数据，返回一个Proxy的代理对象user，被代理者（目标对象）是reactive函数里传入的对象obj
    // 代理对象user，类型是Proxy
    const user = reactive(obj);
    // 打印一下这个响应式代理器对象，其中handler是处理器，target就是传入的目标对象
    console.log (user);
    /*
      Proxy {name: '法外狂徒张三', age: 18, hair: {…}}
        [[Handler]]: Object
          deleteProperty: ƒ deleteProperty(target, key)
          get: ƒ (target, key, receiver)
          has: ƒ has(target, key)
          ownKeys: ƒ ownKeys(target)
          set: ƒ (target, key, value, receiver)
          [[Prototype]]: Object
        [[Target]]: Object
          age: 18
          hair: {length: 180, color: '五彩缤纷的蓝'}
          name: "法外狂徒张三"
          [[Prototype]]: Object
        [[IsRevoked]]: false
    */
    // 方法
    const updateUser = ()=>{
      // 直接以目标对象更新对象中成员的值的方式所更新的数据不是响应式的，只有使用代理对象的方式来更新数据才是响应式的
      // obj.name += '1' // 不触发视图更新
      user.name += '1'
      user.age += 1
      user.hair.color = '五彩斑斓的黑'
    }
    return {
      // 3. 把数据暴露出去
      user,
      updateUser
    };
  },
};
</script>
```
