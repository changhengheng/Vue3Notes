(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{450:function(e,t,r){"use strict";r.r(t);var v=r(65),a=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"reactive-和-ref-细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reactive-和-ref-细节"}},[e._v("#")]),e._v(" reactive 和 ref 细节")]),e._v(" "),r("ul",[r("li",[e._v("是 Vue3 的 composition API 中 2 个最重要的响应式 API")]),e._v(" "),r("li",[e._v("ref 用来处理基本类型数据， reactive 用来处理对象(递归深度响应式)")]),e._v(" "),r("li",[e._v("如果用 ref 对象/数组， 内部会自动将对象/数组转换为 reactive 的代理对象（.value 拿到 reactive 的 Proxy 对象）")]),e._v(" "),r("li",[e._v("ref 内部: 通过给 value 属性添加 getter/setter 来实现对数据的劫持")]),e._v(" "),r("li",[e._v("reactive 内部: 通过使用 Proxy 来实现对对象内部所有数据的劫持， 并通过 Reflect 操作对象内部数据")]),e._v(" "),r("li",[e._v("ref 的数据操作: 在 js 中要.value， 在模板中不需要(内部解析模板时会自动添加.value)")]),e._v(" "),r("li",[e._v("代理对象新增和删除属性的操作也会触发视图更新")])])])}),[],!1,null,null,null);t.default=a.exports}}]);