(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{460:function(t,e,n){"use strict";n.r(e);var x=n(65),r=Object(x.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("当类型被约束后,就拥有了约束类型的所有静态方法")]),t._v(" "),n("p",[t._v("1、普通类型约束")]),t._v(" "),n("p",[t._v("let a:string=xx")]),t._v(" "),n("p",[t._v("2、指定类型和属性")]),t._v(" "),n("p",[t._v("(1)指定对象 \tlet a:{属性1:string,属性2:string}=x    必须是一个对象,且约束了对象属性 \t \t对象中约束函数 \t{方法名():返回值} \t \t通过对象字面量对象来赋值,数据结构必须和定义的接口相同 \t\tlet xx:{属性1:类型,属性2:类型}={属性1:xx,属性2:xx} \t\t通过变量来赋值,数据结构可以增加额外的属性 \t\tlet x={属性1:xx,属性2:xx} \t\tlet xxx:{属性1:类型}=x;  合法")]),t._v(" "),n("p",[t._v("(2)指定元组 \tlet tuple:[类型1,类型2,类型3]=[类型1元素,类型2元素,类型3元素]")]),t._v(" "),n("p",[t._v("(3)指定数组 \tlet arr2:类型[]=[...];   \tlet arr2:(类型1|类型2)=[] \t通过元组来指定数组内单个数组元素不同类型 \tlet x:[类型1,类型2,类型3][]=[[类型1元素,类型2元素,类型3元素],[类型1元素,类型2元素,类型3元素]]")]),t._v(" "),n("p",[t._v("(4)指定类 \tclass X{...} \tlet xx:X=new X();    xx是X类的实例对象或数据结构相同的对象 \tlet xx:X={和类中键相同且数量相同}")]),t._v(" "),n("p",[t._v("(5)指定函数 \t方式一 \t\tfunction xx(x:类型,y:类型):返回值类型{ \t\t\t... \t\t} \t\t函数表达式: \t\tconst fn= function(x:类型,y:类型):返回值类型{ \t\t\t... \t\t} \t\t箭头函数: \t\tconst fn= (x:类型,y:类型):返回值类型=>{ \t\t\t... \t\t} \t方式二 \t\tlet xx:(x:类型,y:类型)=>返回值类型=function(x:类型,y:类型):返回值类型{ \t\t\t... \t\t} \t\t \t对象中指定函数 \t{方法名():返回类型}")]),t._v(" "),n("p",[t._v("3、type约束 type可以声明基本类型别名，联合类型，元组等类型")]),t._v(" "),n("p",[t._v("(1)基本使用 \t\ttype x={ \t\t\tage:number; \t\t} \t\ttype xx=Number")]),t._v(" "),n("p",[t._v("(2)交叉(实现类似接口继承) \t\ttype xxx=x&{sex:string} \t\t \t\t可以实现接口和接口的交叉,但是只能赋值给type类型 \t\ttype x=接口&接口 \t\t \t\t当接口和type都&时,如果其中一个是基本类型,则&结果为基本类型,都是基本类型&结果为never,都是对象进行属性的添加")]),t._v(" "),n("p",[t._v("(3)交叉接口 \t\tinterface y={ \t\t\tname:string \t\t} \t\ttype x1=y&x")]),t._v(" "),n("p",[t._v("(4)使用typeof获取实例的类型进行赋值 \t\tlet div = document.createElement('div'); \t\ttype B = typeof div \t\t \t\tfunction fun(age: number, name: string) { \t\t    return { \t\t      age, \t\t      name \t\t    }; \t\tinterface IObj { \t\t    id?: typeof fun; \ttypeof后只能接变量，不能直接写内容表达式等 \t\t}")]),t._v(" "),n("p",[t._v("4、interface约束 interface可以继承")]),t._v(" "),n("p",[t._v("(1)基本使用 \t\tinterface x={ \t\t\tage:number; \t\t}")]),t._v(" "),n("p",[t._v("(2)继承 \t\ttype xxx=x&{sex:string}")]),t._v(" "),n("p",[t._v("(3)继承type \t\ttype x={ \t\t\tage:number; \t\t} \t\tinterface y extends x{ \t\t\tname:string \t\t}")]),t._v(" "),n("p",[t._v("(4)继承类 \t\tclass X={ \t\t\t属性:类型 \t\t}\t \t\tinterface xx extends X{ \t\t\t属性2:类型 \t\t} \t\tlet xxx:xx={属性:值,属性2:值};")]),t._v(" "),n("p",[t._v("(5)声明合并 \t\tinterface User { \t\t name: string \t\t age: number \t\t} \t\t  \t\tinterface User { \t\t sex: string \t\t} \t\t \t\tUser 接口为 { \t\t name: string \t\t age: number \t\t sex: string  \t\t}")]),t._v(" "),n("p",[t._v("5、约束充当函数 type x=(x1:类型,y1:类型):返回类型 interface y{   \t(x1:类型,y1:类型):返回类型 }")]),t._v(" "),n("p",[t._v("6、约束充当数组 type x=[index:索引类型]:返回类型 interface y{     [index:number索引类型]:类型;   索引为数值,元素为指定类型的数组 }")]),t._v(" "),n("p",[t._v("7、解构赋值约束 let {x,y}:{x:number,y:number}={x:1,y:2}")])])}),[],!1,null,null,null);e.default=r.exports}}]);